<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  

  <title>关于Packet</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  
    <link rel="icon" href="/images/favicon.webp">
  

  <link rel="preload" href="/fonts/Montserrat.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/RobotoMono.woff2" as="font" type="font/woff2" crossorigin>

  <!-- site css -->
  
<link rel="stylesheet" href="/css/fonts.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">


  

  
    
<link rel="stylesheet" href="/css/post.css">

  

  <link href="/vendor/fancybox/5.0.36/fancybox.css" rel="stylesheet">
  <script src="/vendor/fancybox/5.0.36/fancybox.umd.js" defer></script>
  
<script src="/js/fancybox.js"></script>


  
    <script>
      window.__mermaidInitConfig = {
        theme: 'default'
      };
    </script>
    <script src='/vendor/mermaid/11.12.0/mermaid.min.js' defer onload="try{if(window.mermaid){ mermaid.initialize(window.__mermaidInitConfig); }}catch(e){}"></script>
  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="夏眠鱼" type="application/atom+xml">
</head>
  <body>
    <div id="app">
      <div class="header">
  <a href="/">夏眠鱼</a>
</div>


      <p class="links">
  
    <a title="archives" target="" href="/archives/">
      <i class="iconfont icon-bookmark"></i>
    </a>
  
    <a title="tags" target="" href="/tags/">
      <i class="iconfont icon-tags"></i>
    </a>
  
    <a title="about" target="" href="/about/">
      <i class="iconfont icon-envelope"></i>
    </a>
  
</p>

      <div class="main">
        <script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  };
</script>
<script id="MathJax-script" src="/vendor/mathjax/3.2.2/es5/tex-chtml.js" defer></script>

<div class="post">
  <div class="date-tags-container">
    <h3 class="date">
      Sep 14, 2021
    </h3>
    
      <div class="post-tags">
        
          <a href="/tags/net/" class="tag-link">net</a>
        
      </div>
    
  </div>
  <h1>
    关于Packet
  </h1>
  <div class="content markdown-body">
    <p>在搭建Facebook ATC的过程中，发现<a target="_blank" rel="noopener" href="https://www.netacad.com/cisco-packet-tracer">Cisco Packet Tracer</a>（简称PT）可以模拟二三层的工作原理，特别不错。</p>
<p>二层设备是交换机，三层设备是路由器。</p>
<h3 id="交换机的特点"><a href="#交换机的特点" class="headerlink" title="交换机的特点"></a>交换机的特点</h3><ul>
<li>有多个网口（通常24个以上）供终端主机连接</li>
<li>为同一局域网内的主机提供连接</li>
<li>不能为不同局域网或因特网提供连接</li>
</ul>
<h3 id="路由器的特点"><a href="#路由器的特点" class="headerlink" title="路由器的特点"></a>路由器的特点</h3><ul>
<li>网口比交换机少</li>
<li>为不同局域网提供连接</li>
<li>能发送数据到因特网</li>
</ul>
<p>我们通过一个简单的网络拓扑图来讲解包的生命周期。</p>
<p><img src="/../images/net-topology.webp" alt="net-topology"></p>
<p>从该网络拓扑图我们可以得到以下信息：</p>
<table>
<thead>
<tr>
<th align="center">设备</th>
<th align="center">局域网</th>
<th align="center">IP地址</th>
<th align="center">默认网关</th>
<th align="center">MAC地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主机PC1</td>
<td align="center">局域网1<br>192.168.1.0&#x2F;24</td>
<td align="center">192.168.1.1</td>
<td align="center">192.168.1.254</td>
<td align="center">0011</td>
</tr>
<tr>
<td align="center">交换机SW1</td>
<td align="center">局域网1<br>192.168.1.0&#x2F;24</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">路由器R1左端口</td>
<td align="center">局域网1<br>192.168.1.0&#x2F;24</td>
<td align="center">192.168.1.254</td>
<td align="center">-</td>
<td align="center">1254</td>
</tr>
<tr>
<td align="center">路由器R1右端口</td>
<td align="center">局域网2<br>192.168.2.0&#x2F;24</td>
<td align="center">192.168.2.254</td>
<td align="center">-</td>
<td align="center">2254</td>
</tr>
<tr>
<td align="center">交换机SW2</td>
<td align="center">局域网2<br>192.168.2.0&#x2F;24</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">主机PC2</td>
<td align="center">局域网2<br>192.168.2.0&#x2F;24</td>
<td align="center">192.168.2.1</td>
<td align="center">192.168.2.254</td>
<td align="center">0021</td>
</tr>
</tbody></table>
<p>现在我们思考一个问题：PC1 ping PC2的具体过程是怎么样的？这个过程涉及跨子网通信，分三个阶段进行。</p>
<blockquote>
<p>阶段1：获取默认网关R1的MAC地址</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">发起者</th>
<th>动作</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PC1</td>
<td>对目标IP与自身子网掩码做逻辑与运算</td>
<td>判断目标PC2不在同一子网，需通过默认网关转发</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">PC1</td>
<td>查询自身ARP缓存表</td>
<td>检查是否已存储默认网关R1的IP-MAC映射，发现未找到</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">PC1</td>
<td>向SW1发送ARP广播包（目标IP为R1）</td>
<td>请求获取默认网关R1的MAC地址</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">SW1</td>
<td>识别ARP包为广播包，除PC1连接端口外，向所有其他端口广播</td>
<td>将ARP查询请求传递给默认网关R1</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">R1</td>
<td>接收ARP广播包，检查头部发现目标IP为自身</td>
<td>确认自身是ARP查询的目标，准备回应</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">R1</td>
<td>向SW1发送ARP单播回应包（携带自身MAC地址）</td>
<td>告知PC1自己的MAC地址，供后续数据包封装使用</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">SW1</td>
<td>将R1的ARP单播回应包转发给PC1</td>
<td>传递网关MAC地址给发起查询的PC1</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">PC1</td>
<td>更新自身ARP缓存表，记录R1的IP-MAC映射</td>
<td>后续向网关发数据包时，无需重复发起ARP查询</td>
</tr>
</tbody></table>
<blockquote>
<p>阶段2：转发数据包至目标PC2</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">发起者</th>
<th>动作</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PC1</td>
<td>封装目标为PC2的数据包（目标MAC为R1），发送给SW1</td>
<td>将跨子网数据包先发送给默认网关，由网关转发</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SW1</td>
<td>将数据包转发给R1</td>
<td>基于目标R1的MAC，精准传递数据包至网关</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">R1</td>
<td>接收数据包，判断目标IP（PC2）所在子网在自身右端口</td>
<td>确定数据包的下一跳转发端口</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">R1</td>
<td>查询自身ARP缓存表，检查是否存储PC2的IP-MAC映射，发现未找到</td>
<td>确认需发起ARP查询获取PC2的MAC地址</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">R1</td>
<td>从右端口向SW2发送ARP广播包（目标IP为PC2）</td>
<td>请求获取PC2的MAC地址</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">SW2</td>
<td>识别ARP包为广播包，除R1连接端口外，向所有其他端口广播</td>
<td>将ARP查询请求传递给PC2</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">PC2</td>
<td>接收ARP广播包，检查头部发现目标IP为自身</td>
<td>确认自身是ARP查询的目标，准备回应</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">PC2</td>
<td>向SW2发送ARP单播回应包（携带自身MAC地址）</td>
<td>告知R1自己的MAC地址，供后续数据包封装使用</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SW2</td>
<td>将PC2的ARP单播回应包转发给R1</td>
<td>传递目标PC的MAC地址给网关R1</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">R1</td>
<td>更新自身ARP缓存表，记录PC2的IP-MAC映射</td>
<td>后续向PC2发数据包时，无需重复发起ARP查询</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">R1</td>
<td>封装目标为PC2的数据包（目标MAC为PC2），发送给SW2</td>
<td>将数据包从右端口转发至目标PC所在子网的SW2</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">SW2</td>
<td>将数据包转发给PC2</td>
<td>基于目标MAC（PC2），精准传递数据包至目标主机</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">PC2</td>
<td>接收并处理R1转发的数据包</td>
<td>完成跨子网数据包的接收</td>
</tr>
</tbody></table>
<blockquote>
<p>阶段3：PC2向PC1回传回应数据包</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">发起者</th>
<th>动作</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PC2</td>
<td>查询自身ARP缓存表，确认已存储R1的IP-MAC映射（此前通信中已记录）</td>
<td>无需重复发起ARP查询，直接使用缓存的网关MAC</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">PC2</td>
<td>封装回应数据包（目标MAC为R1），发送给SW2</td>
<td>将回应包先发送给网关，由网关回传PC1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SW2</td>
<td>将回应数据包转发给R1</td>
<td>基于目标MAC（R1），传递回应包至网关</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">R1</td>
<td>查询自身ARP缓存表，确认已存储PC1的IP-MAC映射（阶段1已记录）</td>
<td>无需重复发起ARP查询，直接使用缓存的PC1 MAC</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">R1</td>
<td>封装回应数据包（目标MAC为PC1），发送给SW1</td>
<td>将回应包转发至PC1所在子网的交换机</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">SW1</td>
<td>将回应数据包转发给PC1</td>
<td>基于目标MAC（PC1），精准传递回应包至发起端</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">PC1</td>
<td>接收并处理PC2的回应数据包</td>
<td>完成整个跨子网通信的“请求-回应”闭环</td>
</tr>
</tbody></table>
<p>我们留意到，整个过程涉及到三张表：</p>
<ul>
<li>交换机有MAC地址表，存储着MAC地址和端口的映射关系</li>
<li>路由器有路由表，存储着IP和端口的映射关系</li>
<li>主机和路由器都有ARP缓存表，存储着IP和MAC地址的映射关系</li>
</ul>
<p>这三张表是怎么来的：</p>
<ul>
<li>MAC地址表通过局域网内各节点之间不断通过交换机通信逐步完善起来的</li>
<li>路由表是各种路由算法+人工配置逐步完善起来的</li>
<li>ARP缓存表是不断通过ARP协议的请求逐步完善起来的</li>
</ul>
<p>如果用PT单步调式，你会发现原始包的目标IP始终不变，变的只是目标MAC地址，所以其实三层并不具备传输包的功能，而是靠二层去传输。</p>

  </div>
  
    
      <a id="older" class="blog-nav" href="/posts/deploy-atc/">OLDER&nbsp;&gt;</a>
    
    
      <a id="newer" class="blog-nav" href="/posts/about-nat/">&lt;&nbsp;NEWER</a>
    
  
</div>
        <div class="footer">
  
    <div class="footer-more">
      
        © 2016-2025 Kanpu Li. All rights reserved.
        
    </div>
  
</div>

      </div>
      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>


<script src="/js/table.js"></script>


      
  <div class="search-icon" id="search-icon">
    <a href="javascript: void(0)" aria-label="搜索...">
      <i class="iconfont icon-search" aria-hidden="true"></i>
    </a>
  </div>

  <div class="search-overlay hidden" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="search-content" tabindex="0">
      <div class="search-box">
        <div class="search-title">
          
            <input type="text" class="search-input" id="search-input" placeholder="请输入要搜索的内容" aria-label="请输入要搜索的内容">
          
          <span class="search-close-icon" id="search-close-icon">
            <a href="javascript: void(0)" aria-label="Close">
              <i class="iconfont icon-close" aria-hidden="true"></i>
            </a>
          </span>
        </div>
        <div class="search-result" id="search-result"
             data-i18n-noresult="无相关内容"
             data-i18n-files-notfound="未找到search.xml文件，具体请参考："
             data-i18n-service-errors="请求失败，尝试重新刷新页面或稍后重试"></div>
      </div>
    </div>
  </div>

  
<script src="/js/search.js"></script>



    </div>
  </body>
</html>
